<!DOCTYPE html><html lang="CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS socket编程 小白请看这里 | 牛二</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS socket编程 小白请看这里</h1><a id="logo" href="/.">牛二</a><p class="description">春风十里不如你</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS socket编程 小白请看这里</h1><div class="post-meta"><a href="/2018/06/27/iOS-socket编程/#comments" class="comment-count"></a><p><span class="date">Jun 27, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Schlägt</i></i></span></p></div><div class="post-content"><h2 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h2><h3 id="套接字-socket-：简单来讲IP地址-端口号就是套接字-例：192-168-0-102-80-建立网络通信连接至少要一对套接字，客户端套接字就是客户端和外界通信的接口，服务器也一样。"><a href="#套接字-socket-：简单来讲IP地址-端口号就是套接字-例：192-168-0-102-80-建立网络通信连接至少要一对套接字，客户端套接字就是客户端和外界通信的接口，服务器也一样。" class="headerlink" title="套接字(socket)：简单来讲IP地址+端口号就是套接字(例：192.168.0.102:80),建立网络通信连接至少要一对套接字，客户端套接字就是客户端和外界通信的接口，服务器也一样。"></a>套接字(socket)：简单来讲IP地址+端口号就是套接字(例：192.168.0.102:80),建立网络通信连接至少要一对套接字，客户端套接字就是客户端和外界通信的接口，服务器也一样。</h3><h4 id="TCP-IP-可靠的传输层协议-解决数据如何在网络中传输。"><a href="#TCP-IP-可靠的传输层协议-解决数据如何在网络中传输。" class="headerlink" title="TCP/IP: 可靠的传输层协议, 解决数据如何在网络中传输。"></a>TCP/IP: 可靠的传输层协议, 解决数据如何在网络中传输。</h4><h4 id="UDP-不可靠的传输层协议，功能同上。"><a href="#UDP-不可靠的传输层协议，功能同上。" class="headerlink" title="UDP: 不可靠的传输层协议，功能同上。"></a>UDP: 不可靠的传输层协议，功能同上。</h4><h4 id="HTTP-应用层协议，如何包装数据。"><a href="#HTTP-应用层协议，如何包装数据。" class="headerlink" title="HTTP: 应用层协议，如何包装数据。"></a>HTTP: 应用层协议，如何包装数据。</h4><h4 id="Socket：是对TCP-IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP-IP协议。"><a href="#Socket：是对TCP-IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP-IP协议。" class="headerlink" title="Socket：是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。"></a>Socket：是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</h4><p><img src="/2018/06/27/iOS-socket编程/1.jpg" alt="avatar"></p>
<h4 id="建立socket可以使用TCP，也可以使用UDP，使用TCP协议进行连接时，该Socket连接就是一个TCP连接-使用UDP协议进行连接时，该socket就是一个UDP连接，按照HTTP请求的格式，socket可以发送HTTP请求，下边代码有例子。"><a href="#建立socket可以使用TCP，也可以使用UDP，使用TCP协议进行连接时，该Socket连接就是一个TCP连接-使用UDP协议进行连接时，该socket就是一个UDP连接，按照HTTP请求的格式，socket可以发送HTTP请求，下边代码有例子。" class="headerlink" title="建立socket可以使用TCP，也可以使用UDP，使用TCP协议进行连接时，该Socket连接就是一个TCP连接,使用UDP协议进行连接时，该socket就是一个UDP连接，按照HTTP请求的格式，socket可以发送HTTP请求，下边代码有例子。"></a>建立socket可以使用TCP，也可以使用UDP，使用TCP协议进行连接时，该Socket连接就是一个TCP连接,使用UDP协议进行连接时，该socket就是一个UDP连接，按照HTTP请求的格式，socket可以发送HTTP请求，下边代码有例子。</h4><h4 id="形象点来讲，两台电话连接在一起通信-http协议就类似麦克风-把声音信号进行封装-转化为电信号-socket就类似电话机-接收信号或者把信号发送出去。TCP就是把电话线接通并测试通过了才发送封装好的信号，数据完整性好些；UDP就是直接开始发送了，电话线啥时候接通就接收到当前发送的数据-之前发送的数据就丢失了，时效性好些。"><a href="#形象点来讲，两台电话连接在一起通信-http协议就类似麦克风-把声音信号进行封装-转化为电信号-socket就类似电话机-接收信号或者把信号发送出去。TCP就是把电话线接通并测试通过了才发送封装好的信号，数据完整性好些；UDP就是直接开始发送了，电话线啥时候接通就接收到当前发送的数据-之前发送的数据就丢失了，时效性好些。" class="headerlink" title="形象点来讲，两台电话连接在一起通信,http协议就类似麦克风,把声音信号进行封装,转化为电信号,socket就类似电话机,接收信号或者把信号发送出去。TCP就是把电话线接通并测试通过了才发送封装好的信号，数据完整性好些；UDP就是直接开始发送了，电话线啥时候接通就接收到当前发送的数据,之前发送的数据就丢失了，时效性好些。"></a>形象点来讲，两台电话连接在一起通信,http协议就类似麦克风,把声音信号进行封装,转化为电信号,socket就类似电话机,接收信号或者把信号发送出去。TCP就是把电话线接通并测试通过了才发送封装好的信号，数据完整性好些；UDP就是直接开始发送了，电话线啥时候接通就接收到当前发送的数据,之前发送的数据就丢失了，时效性好些。</h4><h4 id="理解了socket在网络通信中的位置，需要socket做的事情就清晰了-1、建立端到端的通信-2、发送数据-3、接受数据"><a href="#理解了socket在网络通信中的位置，需要socket做的事情就清晰了-1、建立端到端的通信-2、发送数据-3、接受数据" class="headerlink" title="理解了socket在网络通信中的位置，需要socket做的事情就清晰了:1、建立端到端的通信 2、发送数据 3、接受数据"></a>理解了socket在网络通信中的位置，需要socket做的事情就清晰了:1、建立端到端的通信 2、发送数据 3、接受数据</h4><h2 id="讲几个socket中常用的c函数："><a href="#讲几个socket中常用的c函数：" class="headerlink" title="讲几个socket中常用的c函数："></a>讲几个socket中常用的c函数：</h2><p>===</p>
<h4 id="int-socket-int-domain-int-type-int-protocol"><a href="#int-socket-int-domain-int-type-int-protocol" class="headerlink" title="int socket(int domain, int type, int protocol);"></a>int socket(int domain, int type, int protocol);</h4><h4 id="创建socket，如果成功则返回一个网络文件描述符（int类型），之后我们操作这个网络连接都通过这个网络文件描述符。"><a href="#创建socket，如果成功则返回一个网络文件描述符（int类型），之后我们操作这个网络连接都通过这个网络文件描述符。" class="headerlink" title="创建socket，如果成功则返回一个网络文件描述符（int类型），之后我们操作这个网络连接都通过这个网络文件描述符。"></a>创建socket，如果成功则返回一个网络文件描述符（int类型），之后我们操作这个网络连接都通过这个网络文件描述符。</h4><h4 id="dimain：域，网络域，网络地址范围（IPV4或IPV6等）-也就是协议簇"><a href="#dimain：域，网络域，网络地址范围（IPV4或IPV6等）-也就是协议簇" class="headerlink" title="dimain：域，网络域，网络地址范围（IPV4或IPV6等）,也就是协议簇"></a>dimain：域，网络域，网络地址范围（IPV4或IPV6等）,也就是协议簇</h4><h4 id="type：指定套接字类型：SOCK-STREAM（TCP网络）、SOCK-DGRAM（UDP）、SOCK-SEQPACKET"><a href="#type：指定套接字类型：SOCK-STREAM（TCP网络）、SOCK-DGRAM（UDP）、SOCK-SEQPACKET" class="headerlink" title="type：指定套接字类型：SOCK_STREAM（TCP网络）、SOCK_DGRAM（UDP）、SOCK_SEQPACKET"></a>type：指定套接字类型：SOCK_STREAM（TCP网络）、SOCK_DGRAM（UDP）、SOCK_SEQPACKET</h4><h4 id="protocol-指定协议，如果指定0，表示使用默认的协议"><a href="#protocol-指定协议，如果指定0，表示使用默认的协议" class="headerlink" title="protocol:指定协议，如果指定0，表示使用默认的协议"></a>protocol:指定协议，如果指定0，表示使用默认的协议</h4><h4 id="上述三个参数在iOS系统中都有相应的宏定义，使用时只需要传入相应的宏定义即可，详见源码部分"><a href="#上述三个参数在iOS系统中都有相应的宏定义，使用时只需要传入相应的宏定义即可，详见源码部分" class="headerlink" title="上述三个参数在iOS系统中都有相应的宏定义，使用时只需要传入相应的宏定义即可，详见源码部分"></a>上述三个参数在iOS系统中都有相应的宏定义，使用时只需要传入相应的宏定义即可，详见源码部分</h4><h4 id="int-connect-int-sockfd-const-struct-sockaddr-addr-socklen-t-addrlen"><a href="#int-connect-int-sockfd-const-struct-sockaddr-addr-socklen-t-addrlen" class="headerlink" title="int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);"></a>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</h4><h4 id="sockfd-客户端自己创建的sock，即上边创建socket函数返回的int值"><a href="#sockfd-客户端自己创建的sock，即上边创建socket函数返回的int值" class="headerlink" title="sockfd(客户端自己创建的sock，即上边创建socket函数返回的int值)"></a>sockfd(客户端自己创建的sock，即上边创建socket函数返回的int值)</h4><h4 id="addr-服务端地址族、服务端IP地址、服务端端口号"><a href="#addr-服务端地址族、服务端IP地址、服务端端口号" class="headerlink" title="addr(服务端地址族、服务端IP地址、服务端端口号)"></a>addr(服务端地址族、服务端IP地址、服务端端口号)</h4><h4 id="addrlen-服务端地址字节长度"><a href="#addrlen-服务端地址字节长度" class="headerlink" title="addrlen(服务端地址字节长度)"></a>addrlen(服务端地址字节长度)</h4><h4 id="返回值：连接成功，返回0，连接失败，返回-1"><a href="#返回值：连接成功，返回0，连接失败，返回-1" class="headerlink" title="返回值：连接成功，返回0，连接失败，返回-1"></a>返回值：连接成功，返回0，连接失败，返回-1</h4><h4 id="int-send-SOCKET-s-const-char-FAR-buf-int-len-int-flags"><a href="#int-send-SOCKET-s-const-char-FAR-buf-int-len-int-flags" class="headerlink" title="int send( SOCKET s,      const char FAR *buf,      int len,      int flags );"></a>int send( SOCKET s,      const char FAR *buf,      int len,      int flags );</h4><h4 id="不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据-如果无错误，返回值为所发送数据的总数，否则返回SOCKET-ERROR。"><a href="#不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据-如果无错误，返回值为所发送数据的总数，否则返回SOCKET-ERROR。" class="headerlink" title="不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据,如果无错误，返回值为所发送数据的总数，否则返回SOCKET_ERROR。"></a>不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据,如果无错误，返回值为所发送数据的总数，否则返回SOCKET_ERROR。</h4><h4 id="客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。"><a href="#客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。" class="headerlink" title="客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。"></a>客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。</h4><h4 id="该函数的第一个参数指定发送端套接字描述符；"><a href="#该函数的第一个参数指定发送端套接字描述符；" class="headerlink" title="该函数的第一个参数指定发送端套接字描述符；"></a>该函数的第一个参数指定发送端套接字描述符；</h4><h4 id="第二个参数指明一个存放应用程序要发送数据的缓冲区；"><a href="#第二个参数指明一个存放应用程序要发送数据的缓冲区；" class="headerlink" title="第二个参数指明一个存放应用程序要发送数据的缓冲区；"></a>第二个参数指明一个存放应用程序要发送数据的缓冲区；</h4><h4 id="第三个参数指明实际要发送的数据的字节数；"><a href="#第三个参数指明实际要发送的数据的字节数；" class="headerlink" title="第三个参数指明实际要发送的数据的字节数；"></a>第三个参数指明实际要发送的数据的字节数；</h4><h4 id="第四个参数一般置0。"><a href="#第四个参数一般置0。" class="headerlink" title="第四个参数一般置0。"></a>第四个参数一般置0。</h4><h4 id="int-recv-SOCKET-s-char-FAR-buf-int-len-int-flags"><a href="#int-recv-SOCKET-s-char-FAR-buf-int-len-int-flags" class="headerlink" title="int recv( SOCKET s,     char FAR *buf,      int len,     int flags     );"></a>int recv( SOCKET s,     char FAR *buf,      int len,     int flags     );</h4><h4 id="不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。"><a href="#不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。" class="headerlink" title="不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。"></a>不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。</h4><h4 id="该函数的第一个参数指定接收端套接字描述符；"><a href="#该函数的第一个参数指定接收端套接字描述符；" class="headerlink" title="该函数的第一个参数指定接收端套接字描述符；"></a>该函数的第一个参数指定接收端套接字描述符；</h4><h4 id="第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；"><a href="#第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；" class="headerlink" title="第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；"></a>第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</h4><h4 id="第三个参数指明buf的长度；"><a href="#第三个参数指明buf的长度；" class="headerlink" title="第三个参数指明buf的长度；"></a>第三个参数指明buf的长度；</h4><h4 id="第四个参数一般置0。-1"><a href="#第四个参数一般置0。-1" class="headerlink" title="第四个参数一般置0。"></a>第四个参数一般置0。</h4><h4 id="int-bind-int-sockfd-const-struct-sockaddr-addr-socklen-t-addrlen"><a href="#int-bind-int-sockfd-const-struct-sockaddr-addr-socklen-t-addrlen" class="headerlink" title="int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);"></a>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</h4><h4 id="服务端套接字绑定自己的IP地址与端口号，客户端那边可以不写，内核会给它分配一个临时的端口。"><a href="#服务端套接字绑定自己的IP地址与端口号，客户端那边可以不写，内核会给它分配一个临时的端口。" class="headerlink" title="服务端套接字绑定自己的IP地址与端口号，客户端那边可以不写，内核会给它分配一个临时的端口。"></a>服务端套接字绑定自己的IP地址与端口号，客户端那边可以不写，内核会给它分配一个临时的端口。</h4><h4 id="sockfd：服务器或者客户端自己创建的socket"><a href="#sockfd：服务器或者客户端自己创建的socket" class="headerlink" title="sockfd：服务器或者客户端自己创建的socket"></a>sockfd：服务器或者客户端自己创建的socket</h4><h4 id="addr-服务器或者客户端自己的地址信息-协议族、IP、端口号"><a href="#addr-服务器或者客户端自己的地址信息-协议族、IP、端口号" class="headerlink" title="addr:服务器或者客户端自己的地址信息(协议族、IP、端口号)"></a>addr:服务器或者客户端自己的地址信息(协议族、IP、端口号)</h4><h4 id="addrlen：服务器或者客户端自己的地址信息的长度"><a href="#addrlen：服务器或者客户端自己的地址信息的长度" class="headerlink" title="addrlen：服务器或者客户端自己的地址信息的长度"></a>addrlen：服务器或者客户端自己的地址信息的长度</h4><h4 id="返回值：绑定成功，返回0，失败返回-1"><a href="#返回值：绑定成功，返回0，失败返回-1" class="headerlink" title="返回值：绑定成功，返回0，失败返回-1"></a>返回值：绑定成功，返回0，失败返回-1</h4><h2 id="源码实现就非常简单了，下边请看iOS建立socket通信的源码："><a href="#源码实现就非常简单了，下边请看iOS建立socket通信的源码：" class="headerlink" title="源码实现就非常简单了，下边请看iOS建立socket通信的源码："></a>源码实现就非常简单了，下边请看iOS建立socket通信的源码：</h2><h3 id="以下源码已经经过简单封装，直接copy到新建项目中即可做简单测试"><a href="#以下源码已经经过简单封装，直接copy到新建项目中即可做简单测试" class="headerlink" title="以下源码已经经过简单封装，直接copy到新建项目中即可做简单测试"></a>以下源码已经经过简单封装，直接copy到新建项目中即可做简单测试</h3><p>===</p>
<h3 id="客户端源码："><a href="#客户端源码：" class="headerlink" title="客户端源码："></a>客户端源码：</h3><p>===</p>
<h3 id="在项目中先导入必要的系统库"><a href="#在项目中先导入必要的系统库" class="headerlink" title="在项目中先导入必要的系统库"></a>在项目中先导入必要的系统库</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="创建socket全局变量"><a href="#创建socket全局变量" class="headerlink" title="创建socket全局变量"></a>创建socket全局变量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _clientSocket;<span class="comment">//全局变量，发送、接受数据以及关闭socket都需要使用</span></span><br></pre></td></tr></table></figure>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 客户端连接服务器</span></span><br><span class="line"><span class="comment">* @param IPAddress 服务器端IP地址</span></span><br><span class="line"><span class="comment">* @param prot 端口号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)connectToServerWithIPAddress:(<span class="built_in">NSString</span> *)IPAddress port:(<span class="keyword">int</span>)port &#123;</span><br><span class="line">_clientSocket = socket(AF_INET,</span><br><span class="line">SOCK_STREAM,</span><br><span class="line">IPPROTO_TCP);<span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(port);</span><br><span class="line">addr.sin_addr.s_addr = inet_addr(IPAddress.UTF8String);</span><br><span class="line"><span class="keyword">int</span> connectResult = connect(_clientSocket,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)&amp;addr,</span><br><span class="line"><span class="keyword">sizeof</span>(addr));<span class="comment">//连接服务器</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,connectResult == <span class="number">0</span> ? <span class="string">@"连接成功"</span> : <span class="string">@"连接失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送和接受数据"><a href="#发送和接受数据" class="headerlink" title="发送和接受数据"></a>发送和接受数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送数据并等待返回数据</span></span><br><span class="line"><span class="comment">* @param message 需要发送的数据</span></span><br><span class="line"><span class="comment">* @Return 接收到的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)sentAndReceiveWithScoketID:(<span class="keyword">int</span>)socketID message:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue =  dispatch_queue_create(<span class="string">"CONCURRENT"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *string = message.UTF8String;</span><br><span class="line">ssize_t sendLength = send(socketID, string, strlen(string), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sendLength == <span class="number">-1</span>) &#123; <span class="built_in">NSLog</span>(<span class="string">@"发送失败"</span>); &#125;</span><br><span class="line"><span class="keyword">char</span> *buf[<span class="number">1024</span>];</span><br><span class="line">ssize_t receiveLength = recv(socketID, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">NSMutableString</span> *mString = [<span class="built_in">NSMutableString</span> string];<span class="comment">//防止数据过长，累加数据</span></span><br><span class="line"><span class="built_in">NSString</span> *receiveString = [[<span class="built_in">NSString</span> alloc]</span><br><span class="line">initWithBytes:buf</span><br><span class="line">length:receiveLength</span><br><span class="line">encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (receiveLength != <span class="number">0</span>) &#123;</span><br><span class="line">receiveLength = recv(socketID, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">NSString</span> * receiveString = [[<span class="built_in">NSString</span> alloc] initWithBytes:buf length:recvLen encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="keyword">if</span> (receiveString != <span class="literal">nil</span>)&#123;</span><br><span class="line">[mString appendString:recvStr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, mString);<span class="comment">//TODO 处理接收到的数据</span></span><br><span class="line"><span class="keyword">return</span> mString.copy;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="send-函数执行后，服务器端的recv-函数会返回接受到的数据，服务器端执行send-函数后，客户端的recv-函数会接收到数据。"><a href="#send-函数执行后，服务器端的recv-函数会返回接受到的数据，服务器端执行send-函数后，客户端的recv-函数会接收到数据。" class="headerlink" title="send()函数执行后，服务器端的recv()函数会返回接受到的数据，服务器端执行send()函数后，客户端的recv()函数会接收到数据。"></a>send()函数执行后，服务器端的recv()函数会返回接受到的数据，服务器端执行send()函数后，客户端的recv()函数会接收到数据。</h4><h4 id="需要注意的是，recv-函数会阻塞当前线程，直到接收到数据返回才会执行下一步，实践过程中，服务器端或者客户单不断发送数据给对方，recv-函数在短时间内可以不断接收到数据，但是一段时间后就接收不到了，或者在第二次就接收不到了，可以使用心跳连接及时获取数据。"><a href="#需要注意的是，recv-函数会阻塞当前线程，直到接收到数据返回才会执行下一步，实践过程中，服务器端或者客户单不断发送数据给对方，recv-函数在短时间内可以不断接收到数据，但是一段时间后就接收不到了，或者在第二次就接收不到了，可以使用心跳连接及时获取数据。" class="headerlink" title="需要注意的是，recv()函数会阻塞当前线程，直到接收到数据返回才会执行下一步，实践过程中，服务器端或者客户单不断发送数据给对方，recv()函数在短时间内可以不断接收到数据，但是一段时间后就接收不到了，或者在第二次就接收不到了，可以使用心跳连接及时获取数据。"></a>需要注意的是，recv()函数会阻塞当前线程，直到接收到数据返回才会执行下一步，实践过程中，服务器端或者客户单不断发送数据给对方，recv()函数在短时间内可以不断接收到数据，但是一段时间后就接收不到了，或者在第二次就接收不到了，可以使用心跳连接及时获取数据。</h4><h4 id="使用socket向百度服务器发送HTTP请求"><a href="#使用socket向百度服务器发送HTTP请求" class="headerlink" title="使用socket向百度服务器发送HTTP请求"></a>使用socket向百度服务器发送HTTP请求</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* 向百度服务器发送HTTP请求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)socketTestBaiDu &#123;</span><br><span class="line"><span class="comment">//连接百度</span></span><br><span class="line">[<span class="keyword">self</span> connectToServer:<span class="string">@"123.125.115.110"</span> port:<span class="number">80</span>];<span class="comment">//网上dns解析下baidu.com，地址就出来了</span></span><br><span class="line"><span class="comment">//发送HTTP格式请求</span></span><br><span class="line"><span class="built_in">NSString</span> *requestStr =<span class="string">@"GET / HTTP/1.1\r\n"</span></span><br><span class="line"><span class="string">"Host: www.baidu.com\r\n"</span></span><br><span class="line"><span class="string">"Connection: close\r\n\r\n"</span>;</span><br><span class="line"><span class="comment">//获取响应</span></span><br><span class="line"><span class="built_in">NSString</span> *responseStr = [<span class="keyword">self</span> sentAndReceiveWithScoketID: _clientSocket  message :requestStr];</span><br><span class="line"><span class="comment">//分离响应体</span></span><br><span class="line"><span class="comment">//    第一种方式分割:</span></span><br><span class="line"><span class="built_in">NSRange</span> range = [responseStr rangeOfString:<span class="string">@"\r\n\r\n"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *htmlStr = [responseStr substringFromIndex:range.location+range.length];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,htmlStr);</span><br><span class="line"><span class="comment">//    第二种方式分割:</span></span><br><span class="line"><span class="built_in">NSArray</span> * htmlArray = [responseStr componentsSeparatedByString:<span class="string">@"\r\n\r\n"</span>];</span><br><span class="line"><span class="built_in">NSString</span> * htmlStr2 = [htmlArray lastObject];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"------------------------------------------"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,htmlStr2);</span><br><span class="line"><span class="comment">//网页数据使用webview来显示</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com/"</span>];</span><br><span class="line">[<span class="keyword">self</span>.webview loadHTMLString:htmlStr baseURL:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关闭socket"><a href="#关闭socket" class="headerlink" title="关闭socket"></a>关闭socket</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 关闭socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)closeSocketWithSocketID:(<span class="keyword">int</span>)socketID&#123;</span><br><span class="line"></span><br><span class="line">shutdown(socketID, SHUT_RDWR);</span><br><span class="line">close(socketID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务器端源码："><a href="#服务器端源码：" class="headerlink" title="服务器端源码："></a>服务器端源码：</h3><h4 id="同样导入上述三个系统库"><a href="#同样导入上述三个系统库" class="headerlink" title="同样导入上述三个系统库"></a>同样导入上述三个系统库</h4><h4 id="创建socket-gt-绑定端口-gt-建立监听"><a href="#创建socket-gt-绑定端口-gt-建立监听" class="headerlink" title="创建socket -&gt; 绑定端口 -&gt; 建立监听"></a>创建socket -&gt; 绑定端口 -&gt; 建立监听</h4><h4 id="创建服务器端socket、客户端socket全局变量"><a href="#创建服务器端socket、客户端socket全局变量" class="headerlink" title="创建服务器端socket、客户端socket全局变量"></a>创建服务器端socket、客户端socket全局变量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _serverSocket;</span><br><span class="line"><span class="keyword">int</span> _clientSocket;</span><br></pre></td></tr></table></figure>
<h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startService&#123;</span><br><span class="line"><span class="built_in">BOOL</span> isListening = [<span class="keyword">self</span> connectAndlistenWithPort:<span class="number">1024</span>];<span class="comment">//监听成功</span></span><br><span class="line"><span class="keyword">if</span> (isListening) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">YES</span>) &#123;<span class="comment">//accept会阻塞线程直到接收到返回值,所以while不会一直循环的</span></span><br><span class="line"><span class="comment">//扫描客户端连接</span></span><br><span class="line">[<span class="keyword">self</span> accept];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 建立监听</span></span><br><span class="line"><span class="comment">* @param port 端口</span></span><br><span class="line"><span class="comment">* @Return 是否监听成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)connectAndlistenWithPort:(<span class="keyword">int</span>)port&#123;</span><br><span class="line">_serverSocket=socket(AF_INET,</span><br><span class="line">SOCK_STREAM ,</span><br><span class="line">IPPROTO_TCP);<span class="comment">//创建</span></span><br><span class="line"><span class="keyword">if</span>(_serverSocket != <span class="number">-1</span>)&#123;<span class="comment">//创建socket成功</span></span><br><span class="line"><span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">memset(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));<span class="comment">//清零操作</span></span><br><span class="line">addr.sin_len=<span class="keyword">sizeof</span>(addr);</span><br><span class="line">addr.sin_family=AF_INET;</span><br><span class="line">addr.sin_port=htons(port);</span><br><span class="line">addr.sin_addr.s_addr=INADDR_ANY;</span><br><span class="line"><span class="keyword">int</span> bindAddr = bind(_serverSocket,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)&amp;addr,</span><br><span class="line"><span class="keyword">sizeof</span>(addr));<span class="comment">//绑定地址和端口号</span></span><br><span class="line"><span class="keyword">if</span> (bindAddr == <span class="number">0</span>) &#123;<span class="comment">//绑定成功</span></span><br><span class="line"><span class="comment">//开始监听</span></span><br><span class="line"><span class="keyword">int</span> startListen = listen(_serverSocket, <span class="number">10</span>);<span class="comment">//10为等待连接数目</span></span><br><span class="line"><span class="keyword">if</span>(startListen == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"监听成功,等待客户端连接"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收客户端消息"><a href="#接收客户端消息" class="headerlink" title="接收客户端消息"></a>接收客户端消息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞直到客户端连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)accept&#123;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in peeraddr;</span><br><span class="line">socklen_t addrLen;</span><br><span class="line">addrLen=<span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line"><span class="comment">//接受到客户端clientSocket连接,获取到地址和端口</span></span><br><span class="line"><span class="keyword">int</span> clientSocket=accept(_serverSocket, (<span class="keyword">struct</span> sockaddr *)&amp;peeraddr, &amp;addrLen);</span><br><span class="line">_clientSocket = clientSocket;</span><br><span class="line"><span class="keyword">if</span> (clientSocket != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"accept success,remote address:%s,port:%d"</span>,inet_ntoa(peeraddr.sin_addr),ntohs(peeraddr.sin_port));</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">size_t len=<span class="keyword">sizeof</span>(buf);</span><br><span class="line"><span class="comment">//接受到客户端消息</span></span><br><span class="line">recv(clientSocket, buf, len, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">NSString</span>* str = [<span class="built_in">NSString</span> stringWithCString:buf encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);<span class="comment">//<span class="doctag">TODO:</span> 处理接收到底数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送并接收客户端消息"><a href="#发送并接收客户端消息" class="headerlink" title="发送并接收客户端消息"></a>发送并接收客户端消息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送数据并等待返回数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)sentAndRecvWithMessage:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> q_con =  dispatch_queue_create(<span class="string">"CONCURRENT"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(q_con, ^&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = message.UTF8String;</span><br><span class="line">send(_clientSocket, str, strlen(str), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">char</span> *buf[<span class="number">1024</span>];</span><br><span class="line">ssize_t receiveLength = recv(_clientSocket, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">NSString</span> *receiveString = [[<span class="built_in">NSString</span> alloc] initWithBytes:buf length:receiveLength encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,receiveString);<span class="comment">//<span class="doctag">TODO:</span>处理接收到的数据</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关闭socket-1"><a href="#关闭socket-1" class="headerlink" title="关闭socket"></a>关闭socket</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> closeSocketWithSocketID: _serverSocket];</span><br><span class="line">[<span class="keyword">self</span> closeSocketWithSocketID: _clientSocket];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 关闭socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)closeSocketWithSocketID:(<span class="keyword">int</span>)socketID&#123;</span><br><span class="line"></span><br><span class="line">shutdown(socketID, SHUT_RDWR);</span><br><span class="line">close(socketID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="本篇到此结束了，对socket了解不多的同学，可以尝试使用上述的代码建立socket连接。"><a href="#本篇到此结束了，对socket了解不多的同学，可以尝试使用上述的代码建立socket连接。" class="headerlink" title="本篇到此结束了，对socket了解不多的同学，可以尝试使用上述的代码建立socket连接。"></a>本篇到此结束了，对socket了解不多的同学，可以尝试使用上述的代码建立socket连接。</h4><h4 id="之后的博客会讲解iOS常用的第三方库CocoaAsyncSocket和iOS原生的NSStream实现的socket"><a href="#之后的博客会讲解iOS常用的第三方库CocoaAsyncSocket和iOS原生的NSStream实现的socket" class="headerlink" title="之后的博客会讲解iOS常用的第三方库CocoaAsyncSocket和iOS原生的NSStream实现的socket"></a>之后的博客会讲解iOS常用的第三方库CocoaAsyncSocket和iOS原生的NSStream实现的socket</h4></div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/06/25/hello-world/" class="next">Hello World</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#扫盲"><span class="toc-text">扫盲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#套接字-socket-：简单来讲IP地址-端口号就是套接字-例：192-168-0-102-80-建立网络通信连接至少要一对套接字，客户端套接字就是客户端和外界通信的接口，服务器也一样。"><span class="toc-text">套接字(socket)：简单来讲IP地址+端口号就是套接字(例：192.168.0.102:80),建立网络通信连接至少要一对套接字，客户端套接字就是客户端和外界通信的接口，服务器也一样。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP-可靠的传输层协议-解决数据如何在网络中传输。"><span class="toc-text">TCP/IP: 可靠的传输层协议, 解决数据如何在网络中传输。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP-不可靠的传输层协议，功能同上。"><span class="toc-text">UDP: 不可靠的传输层协议，功能同上。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-应用层协议，如何包装数据。"><span class="toc-text">HTTP: 应用层协议，如何包装数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket：是对TCP-IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP-IP协议。"><span class="toc-text">Socket：是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#建立socket可以使用TCP，也可以使用UDP，使用TCP协议进行连接时，该Socket连接就是一个TCP连接-使用UDP协议进行连接时，该socket就是一个UDP连接，按照HTTP请求的格式，socket可以发送HTTP请求，下边代码有例子。"><span class="toc-text">建立socket可以使用TCP，也可以使用UDP，使用TCP协议进行连接时，该Socket连接就是一个TCP连接,使用UDP协议进行连接时，该socket就是一个UDP连接，按照HTTP请求的格式，socket可以发送HTTP请求，下边代码有例子。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#形象点来讲，两台电话连接在一起通信-http协议就类似麦克风-把声音信号进行封装-转化为电信号-socket就类似电话机-接收信号或者把信号发送出去。TCP就是把电话线接通并测试通过了才发送封装好的信号，数据完整性好些；UDP就是直接开始发送了，电话线啥时候接通就接收到当前发送的数据-之前发送的数据就丢失了，时效性好些。"><span class="toc-text">形象点来讲，两台电话连接在一起通信,http协议就类似麦克风,把声音信号进行封装,转化为电信号,socket就类似电话机,接收信号或者把信号发送出去。TCP就是把电话线接通并测试通过了才发送封装好的信号，数据完整性好些；UDP就是直接开始发送了，电话线啥时候接通就接收到当前发送的数据,之前发送的数据就丢失了，时效性好些。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#理解了socket在网络通信中的位置，需要socket做的事情就清晰了-1、建立端到端的通信-2、发送数据-3、接受数据"><span class="toc-text">理解了socket在网络通信中的位置，需要socket做的事情就清晰了:1、建立端到端的通信 2、发送数据 3、接受数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#讲几个socket中常用的c函数："><span class="toc-text">讲几个socket中常用的c函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-socket-int-domain-int-type-int-protocol"><span class="toc-text">int socket(int domain, int type, int protocol);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建socket，如果成功则返回一个网络文件描述符（int类型），之后我们操作这个网络连接都通过这个网络文件描述符。"><span class="toc-text">创建socket，如果成功则返回一个网络文件描述符（int类型），之后我们操作这个网络连接都通过这个网络文件描述符。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dimain：域，网络域，网络地址范围（IPV4或IPV6等）-也就是协议簇"><span class="toc-text">dimain：域，网络域，网络地址范围（IPV4或IPV6等）,也就是协议簇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type：指定套接字类型：SOCK-STREAM（TCP网络）、SOCK-DGRAM（UDP）、SOCK-SEQPACKET"><span class="toc-text">type：指定套接字类型：SOCK_STREAM（TCP网络）、SOCK_DGRAM（UDP）、SOCK_SEQPACKET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protocol-指定协议，如果指定0，表示使用默认的协议"><span class="toc-text">protocol:指定协议，如果指定0，表示使用默认的协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上述三个参数在iOS系统中都有相应的宏定义，使用时只需要传入相应的宏定义即可，详见源码部分"><span class="toc-text">上述三个参数在iOS系统中都有相应的宏定义，使用时只需要传入相应的宏定义即可，详见源码部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-connect-int-sockfd-const-struct-sockaddr-addr-socklen-t-addrlen"><span class="toc-text">int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sockfd-客户端自己创建的sock，即上边创建socket函数返回的int值"><span class="toc-text">sockfd(客户端自己创建的sock，即上边创建socket函数返回的int值)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addr-服务端地址族、服务端IP地址、服务端端口号"><span class="toc-text">addr(服务端地址族、服务端IP地址、服务端端口号)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addrlen-服务端地址字节长度"><span class="toc-text">addrlen(服务端地址字节长度)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回值：连接成功，返回0，连接失败，返回-1"><span class="toc-text">返回值：连接成功，返回0，连接失败，返回-1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-send-SOCKET-s-const-char-FAR-buf-int-len-int-flags"><span class="toc-text">int send( SOCKET s,      const char FAR *buf,      int len,      int flags );</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据-如果无错误，返回值为所发送数据的总数，否则返回SOCKET-ERROR。"><span class="toc-text">不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据,如果无错误，返回值为所发送数据的总数，否则返回SOCKET_ERROR。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。"><span class="toc-text">客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#该函数的第一个参数指定发送端套接字描述符；"><span class="toc-text">该函数的第一个参数指定发送端套接字描述符；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二个参数指明一个存放应用程序要发送数据的缓冲区；"><span class="toc-text">第二个参数指明一个存放应用程序要发送数据的缓冲区；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三个参数指明实际要发送的数据的字节数；"><span class="toc-text">第三个参数指明实际要发送的数据的字节数；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第四个参数一般置0。"><span class="toc-text">第四个参数一般置0。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-recv-SOCKET-s-char-FAR-buf-int-len-int-flags"><span class="toc-text">int recv( SOCKET s,     char FAR *buf,      int len,     int flags     );</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。"><span class="toc-text">不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#该函数的第一个参数指定接收端套接字描述符；"><span class="toc-text">该函数的第一个参数指定接收端套接字描述符；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；"><span class="toc-text">第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三个参数指明buf的长度；"><span class="toc-text">第三个参数指明buf的长度；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第四个参数一般置0。-1"><span class="toc-text">第四个参数一般置0。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-bind-int-sockfd-const-struct-sockaddr-addr-socklen-t-addrlen"><span class="toc-text">int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务端套接字绑定自己的IP地址与端口号，客户端那边可以不写，内核会给它分配一个临时的端口。"><span class="toc-text">服务端套接字绑定自己的IP地址与端口号，客户端那边可以不写，内核会给它分配一个临时的端口。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sockfd：服务器或者客户端自己创建的socket"><span class="toc-text">sockfd：服务器或者客户端自己创建的socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addr-服务器或者客户端自己的地址信息-协议族、IP、端口号"><span class="toc-text">addr:服务器或者客户端自己的地址信息(协议族、IP、端口号)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addrlen：服务器或者客户端自己的地址信息的长度"><span class="toc-text">addrlen：服务器或者客户端自己的地址信息的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回值：绑定成功，返回0，失败返回-1"><span class="toc-text">返回值：绑定成功，返回0，失败返回-1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码实现就非常简单了，下边请看iOS建立socket通信的源码："><span class="toc-text">源码实现就非常简单了，下边请看iOS建立socket通信的源码：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#以下源码已经经过简单封装，直接copy到新建项目中即可做简单测试"><span class="toc-text">以下源码已经经过简单封装，直接copy到新建项目中即可做简单测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端源码："><span class="toc-text">客户端源码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在项目中先导入必要的系统库"><span class="toc-text">在项目中先导入必要的系统库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建socket全局变量"><span class="toc-text">创建socket全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#建立连接"><span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送和接受数据"><span class="toc-text">发送和接受数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#send-函数执行后，服务器端的recv-函数会返回接受到的数据，服务器端执行send-函数后，客户端的recv-函数会接收到数据。"><span class="toc-text">send()函数执行后，服务器端的recv()函数会返回接受到的数据，服务器端执行send()函数后，客户端的recv()函数会接收到数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#需要注意的是，recv-函数会阻塞当前线程，直到接收到数据返回才会执行下一步，实践过程中，服务器端或者客户单不断发送数据给对方，recv-函数在短时间内可以不断接收到数据，但是一段时间后就接收不到了，或者在第二次就接收不到了，可以使用心跳连接及时获取数据。"><span class="toc-text">需要注意的是，recv()函数会阻塞当前线程，直到接收到数据返回才会执行下一步，实践过程中，服务器端或者客户单不断发送数据给对方，recv()函数在短时间内可以不断接收到数据，但是一段时间后就接收不到了，或者在第二次就接收不到了，可以使用心跳连接及时获取数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用socket向百度服务器发送HTTP请求"><span class="toc-text">使用socket向百度服务器发送HTTP请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭socket"><span class="toc-text">关闭socket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器端源码："><span class="toc-text">服务器端源码：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同样导入上述三个系统库"><span class="toc-text">同样导入上述三个系统库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建socket-gt-绑定端口-gt-建立监听"><span class="toc-text">创建socket -&gt; 绑定端口 -&gt; 建立监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建服务器端socket、客户端socket全局变量"><span class="toc-text">创建服务器端socket、客户端socket全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动服务器"><span class="toc-text">启动服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主要方法"><span class="toc-text">主要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接收客户端消息"><span class="toc-text">接收客户端消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送并接收客户端消息"><span class="toc-text">发送并接收客户端消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭socket-1"><span class="toc-text">关闭socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本篇到此结束了，对socket了解不多的同学，可以尝试使用上述的代码建立socket连接。"><span class="toc-text">本篇到此结束了，对socket了解不多的同学，可以尝试使用上述的代码建立socket连接。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#之后的博客会讲解iOS常用的第三方库CocoaAsyncSocket和iOS原生的NSStream实现的socket"><span class="toc-text">之后的博客会讲解iOS常用的第三方库CocoaAsyncSocket和iOS原生的NSStream实现的socket</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/27/iOS-socket编程/">iOS socket编程 小白请看这里</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">Über</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">NE.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>